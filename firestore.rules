rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    function isAuthed() {
      return request.auth != null;
    }

    function isOwner(ownerUid) {
      return isAuthed() && request.auth.uid == ownerUid;
    }

    // ---- Engagement updates allowed for NON-owners ----
    // This supports two patterns:
    // A) counts map: counts.echoes / counts.splashes
    // B) legacy top-level: echoesCount / splashesCount
    // Plus optional preview fields and updatedAt.
    function isLegitEngagementUpdate() {
      let changedTop = request.resource.data.diff(resource.data).changedKeys();

      // Allow ONLY these top-level fields to change for non-owners:
      // counts OR legacy counters OR lastEcho preview OR updatedAt
      let topOk = changedTop.hasOnly([
        'counts',
        'echoesCount',
        'splashesCount',
        'lastEchoText',
        'lastEchoBy',
        'lastEchoAt',
        'updatedAt'
      ]);

      // ---- counts-map mode checks ----
      let oldCounts = resource.data.counts;
      let newCounts = request.resource.data.counts;
      let safeOldCounts = oldCounts == null ? {} : oldCounts;

      // If counts exists in request, only echoes/splashes/hugs may change
      let countsKeysOk =
        (newCounts == null) ||
        newCounts.diff(safeOldCounts).changedKeys().hasOnly(['echoes','splashes','hugs']);

      let countsTypesOk =
        (newCounts == null) ||
        (
          (!('echoes' in newCounts) || newCounts.echoes is number) &&
          (!('splashes' in newCounts) || newCounts.splashes is number) &&
          (!('hugs' in newCounts) || newCounts.hugs is number)
        );

      // ---- legacy counter mode checks ----
      let legacyOk =
        (!('echoesCount' in request.resource.data) || request.resource.data.echoesCount is number) &&
        (!('splashesCount' in request.resource.data) || request.resource.data.splashesCount is number);

      // ---- preview fields checks (optional) ----
      let previewOk =
        (!('lastEchoText' in request.resource.data) || request.resource.data.lastEchoText is string) &&
        (!('lastEchoBy' in request.resource.data) || request.resource.data.lastEchoBy is string) &&
        (!('lastEchoAt' in request.resource.data) || request.resource.data.lastEchoAt is timestamp);

      return topOk && countsKeysOk && countsTypesOk && legacyOk && previewOk;
    }

    // waves/{waveId}
    match /waves/{waveId} {
      allow read: if true;

      allow create: if isAuthed()
                    && request.resource.data.ownerUid == request.auth.uid;

      // Owner can update freely.
      // Non-owners can ONLY do legit engagement updates.
      allow update: if isAuthed() && (
        resource.data.ownerUid == request.auth.uid ||
        isLegitEngagementUpdate()
      );

      allow delete: if isAuthed()
                    && resource.data.ownerUid == request.auth.uid;

      // waves/{waveId}/splashes/{uid}
      match /splashes/{uid} {
        allow read: if true;

        allow create: if isAuthed()
                      && uid == request.auth.uid
                      && request.resource.data.userUid == request.auth.uid;

        allow update: if false;

        allow delete: if isAuthed() && uid == request.auth.uid;
      }

      // waves/{waveId}/echoes/{echoId}
      match /echoes/{echoId} {
        allow read: if true;

        // Allow create with either "userUid" or "authorId" field
        // (some clients use authorId; this makes it work for everyone)
        allow create: if isAuthed()
                      && (
                        (request.resource.data.userUid == request.auth.uid) ||
                        (request.resource.data.authorId == request.auth.uid)
                      )
                      && request.resource.data.text is string
                      && request.resource.data.text.size() > 0
                      && request.resource.data.text.size() <= 2000;

        // Update only by the author; only text can change
        allow update: if isAuthed()
                      && (
                        (resource.data.userUid == request.auth.uid) ||
                        (resource.data.authorId == request.auth.uid)
                      )
                      && request.resource.data.diff(resource.data)
                           .changedKeys().hasOnly(["text"]);

        allow delete: if isAuthed()
                      && (
                        (resource.data.userUid == request.auth.uid) ||
                        (resource.data.authorId == request.auth.uid)
                      );
      }
    }

    // users/{uid}
    match /users/{uid} {
      allow read: if isAuthed();
      allow create, update, delete: if isOwner(uid);

      match /pings/{pingId} {
        allow read, create, update, delete: if isAuthed();
      }

      match /crew/{memberId} {
        allow read: if isAuthed();
        allow create, delete: if isAuthed()
                              && memberId == request.auth.uid;
        allow update: if false;
      }

      match /boarding/{targetId} {
        allow read: if isOwner(uid);
        allow create, delete: if isOwner(uid);
        allow update: if false;
      }

      match /recentPosters/{posterId} {
        allow read: if isOwner(uid);
        allow create, update, delete: if isOwner(uid);
      }

      match /mentions/{mentionId} {
        allow read, update, delete: if isOwner(uid);
        allow create: if isAuthed();
      }

      match /messages/{messageId} {
        allow read, update, delete: if isOwner(uid);
        allow create: if isAuthed();
      }
    }
  }
}